<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>웹툰 관리자</title>
    <style>
        /* CSS 스타일은 이전과 동일하므로 생략합니다. */
        /* 이전에 제공된 CSS 코드를 그대로 사용하시면 됩니다. */
    </style>
</head>
<body>
    <div class="container">
        </div>

    <script>
        let originalWebtoonData = [];
        let filteredWebtoonData = [];
        let currentPage = 1;
        const itemsPerPage = 10;
        let checkedItems = new Set();
        const CACHE_KEY = 'webtoons.json'; // [변경] 이제 JSON 파일을 직접 캐시처럼 사용
        let currentEpisodeFilter = 0;

        function loadCheckedItems() {
            try {
                const saved = localStorage.getItem('checkedBlackToonWebtoons');
                if (saved) checkedItems = new Set(JSON.parse(saved));
            } catch (e) {
                console.error('체크 상태 로드 실패:', e);
            }
        }

        function saveCheckedItems() {
            localStorage.setItem('checkedBlackToonWebtoons', JSON.stringify([...checkedItems]));
        }

        function applyFiltersAndRender() {
            if (originalWebtoonData.length > 0) {
                document.getElementById('stats').style.display = 'flex';
                document.getElementById('filter-container').style.display = 'block';
                
                let dataToRender = [...originalWebtoonData];
                if (currentEpisodeFilter > 0) {
                    dataToRender = dataToRender.filter(w => w.episodes >= currentEpisodeFilter);
                }
                
                filteredWebtoonData = dataToRender;
                currentPage = 1;
                renderAll();
            } else {
                document.getElementById('webtoonList').innerHTML = '<div style="text-align: center; padding: 40px; color: #6b7280;">표시할 웹툰이 없습니다. downloader.py를 먼저 실행해주세요.</div>';
                document.getElementById('stats').style.display = 'none';
                document.getElementById('filter-container').style.display = 'none';
            }
        }
        
        function deleteCheckedItems() {
            if (checkedItems.size === 0) {
                alert('삭제할 항목을 먼저 체크해주세요.');
                return;
            }
            if (confirm(`체크된 ${checkedItems.size}개의 항목을 목록에서 영구히 삭제하시겠습니까? (이 작업은 되돌릴 수 없습니다)`)) {
                alert("삭제 기능은 현재 버전에서는 지원되지 않습니다. webtoons.json 파일을 직접 수정해주세요.");
            }
        }

        // [변경] 이제 백엔드 API 대신 webtoons.json 파일을 직접 fetch합니다.
        async function loadWebtoonsFromFile() {
            const loadBtn = document.getElementById('loadBtn');
            const loading = document.getElementById('loading');
            loadBtn.disabled = true;
            loading.style.display = 'block';
            
            try {
                // './webtoons.json' 파일을 직접 요청
                const response = await fetch('./webtoons.json?v=' + Date.now()); // 캐시 방지용 파라미터 추가
                if (!response.ok) throw new Error('webtoons.json 파일을 불러올 수 없습니다.');
                
                const rawData = await response.json();
                originalWebtoonData = rawData.sort((a,b) => b.episodes - a.episodes);
                
                // 데이터를 localStorage에도 저장 (선택사항, 더 빠른 로딩을 위함)
                localStorage.setItem(CACHE_KEY, JSON.stringify(originalWebtoonData));

                applyFiltersAndRender();
            } catch (error) {
                console.error('웹툰 로드 실패:', error);
                showError(error.message);
            } finally {
                loading.style.display = 'none';
                loadBtn.disabled = false;
            }
        }

        function renderAll() {
            renderWebtoons();
            renderPagination();
            updateStats();
        }

        function renderWebtoons() {
            const container = document.getElementById('webtoonList');
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageData = filteredWebtoonData.slice(startIndex, endIndex);

            if (pageData.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #6b7280;">이 조건에 맞는 웹툰이 없습니다.</div>';
                return;
            }
            container.innerHTML = pageData.map(webtoon => `
                <div class="webtoon-item ${checkedItems.has(webtoon.id) ? 'checked' : ''}">
                    <input type="checkbox" class="checkbox" data-id="${webtoon.id}" ${checkedItems.has(webtoon.id) ? 'checked' : ''}>
                    <img src="${webtoon.thumbnail}" class="thumbnail" alt="${webtoon.title}" onerror="this.style.display='none'">
                    <div class="webtoon-info">
                        <div class="webtoon-title"><a href="${webtoon.url}" target="_blank">${webtoon.title}</a></div>
                        <div class="webtoon-episodes">${webtoon.episodes}화</div>
                        <div class="webtoon-author">작가: ${webtoon.author}</div>
                    </div>
                </div>`).join('');

            container.querySelectorAll('.checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const id = parseInt(this.dataset.id);
                    this.closest('.webtoon-item').classList.toggle('checked', this.checked);
                    if (this.checked) checkedItems.add(id);
                    else checkedItems.delete(id);
                    saveCheckedItems();
                    updateStats();
                });
            });
        }

        // [수정] 버그 수정된 페이지네이션 함수
        function renderPagination() {
            const totalPages = Math.ceil(filteredWebtoonData.length / itemsPerPage);
            const container = document.getElementById('pagination');
            if (totalPages <= 1) {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'flex';
            let paginationHTML = `<button class="page-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">이전</button>`;
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            for (let page = startPage; page <= endPage; page++) {
                paginationHTML += `<button class="page-btn ${page === currentPage ? 'active' : ''}" onclick="changePage(${page})">${page}</button>`;
            }
            paginationHTML += `<button class="page-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">다음</button><div class="page-info">${currentPage} / ${totalPages} 페이지</div>`;
            container.innerHTML = paginationHTML;
        }
        
        // [수정] 버그 수정된 페이지 변경 함수
        function changePage(page) {
            const totalPages = Math.ceil(filteredWebtoonData.length / itemsPerPage);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                renderWebtoons();
                renderPagination();
                window.scrollTo(0, 0);
            }
        }
        
        function updateStats() {
            document.getElementById('totalCount').textContent = filteredWebtoonData.length;
            document.getElementById('checkedCount').textContent = checkedItems.size;
            const totalEpisodes = filteredWebtoonData.reduce((sum, w) => sum + w.episodes, 0);
            const avgEpisodes = filteredWebtoonData.length > 0 ? Math.round(totalEpisodes / filteredWebtoonData.length) : 0;
            document.getElementById('avgEpisodes').textContent = avgEpisodes;
        }

        function showError(message) {
             document.getElementById('webtoonList').innerHTML = `<div class="error-message"><h3>⚠️ 오류 발생</h3><p>${message}</p></div>`;
        }

        document.addEventListener('DOMContentLoaded', function() {
            loadCheckedItems();
            loadWebtoonsFromFile(); // 페이지 로드 시 파일에서 데이터 로드
            
            document.getElementById('loadBtn').addEventListener('click', loadWebtoonsFromFile);
            document.getElementById('deleteCheckedBtn').addEventListener('click', deleteCheckedItems);
            // 전체 캐시 삭제 기능은 localStorage를 사용하지 않으므로 숨기거나 다른 용도로 사용
            document.getElementById('clearCacheBtn').style.display = 'none';

            document.querySelectorAll('.filter-btn').forEach(button => {
                button.addEventListener('click', function() {
                    document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    currentEpisodeFilter = parseInt(this.dataset.filter);
                    applyFiltersAndRender();
                });
            });
        });
    </script>
</body>
</html>